# Runner

This repository contains a solution for a full-featured docker-enabled gitlab runner.

Features:

* possibility to run build commands utilizing docker
* builds are completely isolated from the host and run in a docker container
* easy to use solution with two containers (runner and sandbox)


## Overview

When running CI tasks which include interaction with docker, it is quite hard to make a secure
solution at least not allowing to access the hardware and/or root of the host machine.

This solution tries to build a complete secure solution of a gitlab runner using the
docker-in-docker approach being completely secure.

The solution consists of two standalone containers:

1. `runner` - the gitlab runner itself
2. `sandbox` - is the image used by the gitlab runner as the executor and acting as a sandbox
   for running the CI tasks

In a typical scenario, the runner image is listening for tasks generated by the given gitlab site and
executing the tasks in the `sandbox` container via ssh.

It is intended, that the `sandbox` image is not run via the standard `runc` runtime, but
instead the runtime [sysbox-runc](https://github.com/nestybox/sysbox/) should be used, since only
this runtime gives the sandbox the necessary security layer to be a real sandbox.

The `sandbox` image may also be used as a standalone image for executing any docker-enabled tasks
in a sandbox environment. 

### runner

To be written.


### sandbox

Effectively any user allowed to access docker may easily elevate his
privileges to root and it would be very hard to restrict this elevation. The sandbox image
is designed in a way, that becoming root is not restricted, but the `sysbox-runc` runtime
is effectively restricting this root access to do anything wrong on the host machine.

I.e. any user performing tasks in the sandbox may maybe destroy the whole sandbox container,
but will never gain the root privileges of the host machine and can therefore not destroy
the host machine. In such a case just recreating the container would be necessary to fix
any damage being performed by a nasty task.

#### using the container

The sandbox image is accessible using ssh, ssh is always listening on the port 22.

Access to the ssh is available only for the `sandbox` user authorized by an ssh key. Authorized
ssh keys should be passed to the `AUTHORIZED_KEYS` environment variable. The format of this
variable is the same as the format of the `~/.ssh/authorized_keys` file.

Server ssh host keys are **intentionally** pregenerated and therefore **insecure**. It is because
ssh keys could be anyway leaked from the sandbox and therefore nobody should rely on the used
host keys security. **Connect to the sandbox only from a secure network.**
